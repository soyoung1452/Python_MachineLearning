In this programming assignment, you will build a simple indexing and retrieval system.


For the assignment, use the stories dataset available at http://archives.textfiles.com/stories.zip.
Among stories in the dataset, you can remove some malformed stories (e.g., those formatted by HTML).
Write your code in C++, Java, Python, or any other programming language you prefer to use.



Specifically, it involves the following tasks:

1. Build a uni-gram inverted index over terms of the dataset.
- Preprocess documents in the dataset to remove punctuations and numbers, perform normalization, e.g., to upper case, (and stemming - optional).
- Use the SPIMI-Invert algorithm. But, assume that free memory is enough to keep a whole index as well as the dataset. That is, you don't need to write the index and dictionary to disk.

SPIMI는 메모리 내에서 데이터를 한 번만 스캔하면서 인덱스를 생성하는 방법.
작은 규모의 데이터 셋이나 메모리 용량이 충분한 경우에 유용하게 활용
처리 시간이 단축되고, 메모리 용량을 효율적으로 활용할 수 있습니다. 그러나 메모리에 모든 데이터를 저장해야 하므로 대량의 데이터셋이나 메모리 제약이 있는 환경에서는 적용하기 어렵습니다. 또한, 데이터의 변경이 발생하면 인덱스를 업데이트해야 하기 때문에 실시간으로 데이터를 업데이트하는 시스템에는 적합하지 않을 수 있습니다.
Single-pass in-memory indexing은 주로 인메모리 데이터베이스나 캐시 시스템에서 활용되며, 빠른 응답 시간과 데이터 액세스 성능을 요구하는 애플리케이션에 유용합니다.
단계
- 데이터 스캔 : 인덱스를 생성할 대상 데이터를 한 번만 스캔. 이때 데이터는 일련의 레코드로 구성
- 인덱스 구성 : 스캔한 데이터를 기반으로 인덱스를 구성. 일반적으로 메모리 내에 해시 테이블, 트리 구조 등의 인덱스 데이터 구조를 생성
- 인덱스 활용 : 인덱스를 사용하여 검색, 정렬 또는 필터링과 같은 작업 수행. 이때 인덱스는 메모리에 상주하므로 빠른 액세스와 처리 속도를 제공한다.



2. Implement Boolean retrieval for the following queries. 

- X OR Y

- X AND Y
- X AND NOT Y

- X OR NOT Y



3. Implement ranked retrieval using tf-idf scoring that supports free text queries.
- Implement it using TAAT
"자유 텍스트 쿼리를 지원하고 TF-IDF 스코어링을 사용하여 랭크된 검색을 TAAT(Term-At-A-Time) 방식으로 구현하세요."
- 자유 텍스트 쿼리: 자유로운 텍스트 쿼리를 입력으로 받는 기능을 의미한다. 사용자가 원하는 검색어를 자유롭게 입력할 수 있어야 한다. 예를 들어 "apple", "red apple" 등 다양한 텍스트 쿼리를 지원해야 한다.
- TF-IDF 스코어링": 검색어와 문서 간의 중요도 계산을 위해 TF-IDF 스코어링 방법을 사용한다. 이 방법은 검색어의 단어 빈도와 문서 전체에서의 단어 빈도를 고려하여 각 문서의 중요도를 계산하는 방식이다. 검색어에 포함된 단어가 문서에서 더 자주 나타날수록 해당 문서의 중요도가 높아진다.
- TAAT(Term At A Time) 방식: 검색어에 포함된 각 단어에 대해, 해당 단어가 나타나는 모든 문서를 한 번에 처리하는 방식을 의미한다. 즉, 각 단어에 대한 문서 집합의 교집합을 계산하고, 이를 기반으로 문서의 랭크를 계산한다. TAAT 방식은 모든 단어에 대한 문서 집합을 한 번에 처리하기 때문에 효율적인 검색을 할 수 있다.

따라서, 이 요구사항을 구현하기 위해서는 사용자로부터 자유로운 텍스트 쿼리를 입력받고, 각 단어에 대한 TF-IDF 스코어를 계산하여 문서의 랭크를 결정해야 합니다. 이때 TAAT 방식을 사용하여 모든 단어에 대한 문서 집합의 교집합을 계산하고, 이를 기반으로 문서의 랭크를 정렬하여 출력합니다.


4. Write up a report describing your program and results.
- Describe your program. Do not include the source code in the report.

- Describe whatever you think is meaningful. The following are just guideline, and you don't necessarily follow them.



Guideline for report

1) Report statistics of the index.
2) Report results for a few sample Boolean queries.

3) Report results of free text queries for ranked retrieval.

4) If possible, compare the results of Boolean retrieval with that of ranked retrieval.

Boolean retrieval과 ranked retrieval은 검색 결과를 다르게 제공하는 두 가지 방식입니다. Boolean retrieval은 논리 연산자를 사용하여 정확히 일치하는 문서를 찾아주는 방식이고, ranked retrieval은 문서의 랭크를 계산하여 가장 관련성이 높은 순서대로 정렬하여 제공하는 방식입니다.

두 방식의 결과를 비교하기 위해서는 다음과 같은 접근 방법을 사용할 수 있습니다:

쿼리 입력: 동일한 쿼리를 사용하여 Boolean retrieval과 ranked retrieval을 실행합니다. 예를 들어, "apple"이라는 검색어를 사용합니다.

결과 집합 비교: Boolean retrieval과 ranked retrieval의 결과 집합을 비교합니다. 두 방식에서 반환된 문서 집합을 확인하여 공통된 문서가 있는지 확인합니다.

랭크 비교: 공통된 문서가 있다면, ranked retrieval에서 반환된 랭크 정보를 확인합니다. ranked retrieval은 문서의 랭크를 계산하여 가장 관련성이 높은 순서대로 정렬하므로, 랭크가 높은 문서가 상위에 위치합니다.

검토 및 비교: 공통된 문서가 있고 랭크 정보가 제공된 경우, 랭크 정보를 기준으로 문서의 순서를 비교합니다. ranked retrieval에서 상위에 위치한 문서가 보다 관련성이 높다고 볼 수 있습니다.

이와 같은 방법을 통해 Boolean retrieval과 ranked retrieval의 결과를 비교하고, 상대적인 검색 효과를 평가할 수 있습니다. 물론 검색 시나리오와 데이터에 따라 결과가 달라질 수 있으므로, 일반적인 비교 방법으로 참고해야 합니다.


5. Submit your source code in a zip file and report in a pdf file.

